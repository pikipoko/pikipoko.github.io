---
title: "TIL24"
date: 28/10/2022
categories: SWJG TIL
---

## TD

- [ ] 컴시 9.9장 내용 정리  
- [ ] c malloc lab : implicit 방식 구현  
- [X] 물 많이 마시기  
- [X] 1일 1로그  

## 1D1L

> 그러므로 우리는 메모리를 계층 구조로 만들 가능성이 있음을 결국 인식하게 된다. 여기서 각 단계의 메모리는 앞 단계보다 용량은 더 크고 접근 속도는 느리다.

### 캐시

- 용량이 작고 속도가 빠른 메모리.
- 용량이 더 크지만 훨씬 느린 주 기억 장치에 매번 접근하는 것을 피하고자 __최근에 사용된 정보를 저장__ 하는 데 사용.

### 캐싱

- 캐싱은 우리가 뭔가를 사용하고 있고 그것을 __곧 다시 사용할 가능성(시간적 지역성)__ 이 있거나, __근처에 있는 무언가를 사용할 가능성(공간적 지역성)__ 이 있을 때 언제든지 활용할 수 있는 훨씬 더 일반적인 개념이다.
- 캐싱이 효과적인 이유는 최근에 사용된 정보가 곧 다시 사용될 가능성이 크기 때문.
- 네트워크에서는 멀리 떨어져 있는 서버에서 오는 정보 흐름의 속도를 높이려고 캐시를 사용할 때가 많고, 서버 자체에도 캐시가 있다.

## 동적 메모리 할당

>C 프로그래머들은 대개 추가적인 __가상메모리__ 를 __런타임__ 에 획득할 필요가 있을 때, __동적 메모리 할당기__ 를 사용하는 것을 좀 더 편리하고 호환성이 좋다고 생각한다.

---

프로그램들이 동적 메모리 할당을 사용하는 가장 중요한 이유는 종종 이들이 프로그램을 실제 실행시키기 전에는 자료구조의 크기를 알 수 없는 경우들이 있기 때문이다.

---

__동적 메모리 할당기__ 는 __힙__(heap, 프로세스의 가상메모리 영역)을 관리한다. 힙은 미초기화된 데이터 영역(.bss) 직후에 시작해서 위쪽으로(높은 주소 방향으로) 커지는 무요구 메모리 영역이라고 생각하면 된다. 각각의 프로세스에 대해서, __커널__ 은 힙의 꼭대기를 가리키는 변수 brk(break)를 사용한다.

---

할당기는 힙을 다양한 크기의 블록들의 집합으로 관리한다. __가용 블록__ 은 application이 명시적으로 할당할 때까지 가용한 상태로 남아 있다. __할당된 블록__ 은 application에 의해 명시적으로 또는 메모리 할당기에 의해 묵시적으로 반환될 때까지 할당된 채로 남아 있다.  

- 가용 블록 - free했거나 malloc 하지않은 블록
- 할당된 블록 - malloc한 블록)

### 명시적인 할당기 explicit allocator

응용이 명시적으로 할당된 블록을 반환해 줄 것을 요구한다.

- C 표준 라이브러리는 __malloc 패키지__ 로 알려진 명시적 할당기 제공.

### 묵시적 할당기 implicit allocator (garbage collector)

언제 할당된 블록이 더 이상 프로그램에 의해 사용되지 않고 블록을 반환하는지를 할당기가 검출할 수 있을 것을 요구한다. 자동으로 사용하지 않은 할당된 블록을 반환시켜주는 작업을 __가비지 컬렉션__ 이라고 부른다.

### malloc, calloc, realloc, sbrk

- malloc - 메모리 공간만 확보해서 메모리 공간의 시작 주소 리턴, 초기화 x
- calloc - malloc + 0으로 초기화
- realloc - 이전에 할당된 블록의 크기를 변경
- sbrk - 커널의 brk 포인터에 incr을 더해서 힙을 늘리거나 줄인다.
- free - 할당된 블록의 시작점을 받아서 가용 블록으로 변환. __아무것도 리턴하지 않기 때문에 application에게 뭔가 잘못되었다는 것을 알릴 수 없다.__

---

    #include <stdlib.h>
    void *malloc(size_t size);
            Returns: pointer to allocated block if OK, NULL on error

    #include <unistd.h>
    void *sbrk(intptr_t incr);
            Returns: old brk pointer on success, -1 on error

    #include <stdlib.h>
    void free(void *ptr);
            Returns: nothing

### 할당기 요구사항과 목표

- 요구사항

1. 임의의 요청 순서 처리하기
2. 요청에 즉시 응답하기
3. 힙만 사용하기
4. 블록 정렬하기(정렬 요건)
5. 할당된 블록을 수정하지 않기

- 목표

1. 처리량 극대화하기
    - 처리량 : 할당과 반환 요청들
2. 메모리 이용도를 최대화하기
    - 최고 이용도(peak utilization)

### 단편화

나쁜 힙 이용도의 주요 이유는 단편화라고 알려진 현상인데, 이것은 가용 메모리가 할당 요청을 만족시키기에는 가용하지 않았을 때 일어난다.

- 내부 단편화 : 할당된 블록이 데이터 자체보다 더 클 때 일어난다.
- 외부 단편화 : 할당 요청을 만족시킬 수 있는 메모리 공간이 전체적으로 공간을 모았을 때는 충분한 크기가 존재하지만, 이 요청을 처리할 수 있는 단이란 가용블록은 없는 경우에 발생.

## mm.c

    function
        int     mm_init
        void    *mm_malloc
        void    mm_free
        void    *mm_realloc

## memlib.c

    function
        void    mem_init
        void    mem_deinit
        void    mem_reset_brk
        void    *mem_sbrk
        void    *mem_heap_lo
        void    *mem_heap_hi
        size_t  mem_heapsize
        size_t  mem_pagesize

## void 포인터 (void *)

현재의 타입이 없지만 캐스팅(casting)을 통해 어떤 타입으로도 변신이 가능한 만능 포인터이다. __포인터에서의 void__ 는 현재 그 타입이 정해지지 않았다는 의미로 볼 수 있다. __void 포인터는 순수하게 메모리의 주소만 가지고 있는 포인터__ 이며 어떤 대상을 가리키는지가 정해져 있지 않다.
