---
title: "TIL23"
date: 27/10/2022
categories: SWJG TIL
---

## TD

- 물 많이 마시기
- 컴시 정리

## 1일 1로그_14

프로세서는 인출(fetch), 해석, 실행 사이클을 계속 반복 수행한다.  

1. 우선 메모리에서 다음에 처리할 명령어를 인출한다.
2. 인출한 명령어를 해석한다.
3. 명령어를 실행한다.

### 컴퓨터 아키텍처

- 프로세서 설계와 더불어 프로세서와 컴퓨터 나머지 부분 간의 연결 방식 설계를 다루는 분야.
- 컴퓨터 아키텍처 분야의 주요 관심사 중 하나는 __명령어 집합(instruction set)__.

컴퓨터 아키텍처는 기능성, 속도, 복잡도, 전력 소모 정도, 프로그램 가능성 등 상충하는 요구 간 복잡한 트레이드 오프(tradeoff)를 수반한다.  

> 일반적으로 산술 장치의 내부 자원 운영은 빠른 연산 속도에 대한 욕구와 (중략) 기계의 단순성 또는 저비용에 대한 욕구 사이의 절충으로 결정된다.

### CPU와 메인 메모리 간의 속도 차이

CPU에 비해 메모리는 몹시 느리다. 이 속도 차이를 해결하기 위해 현대 컴퓨터 아키텍처는 캐시라는 고속 메모리를 사용한다. 캐시는 프로세서와 메모리 사이에 있고 최근 사용된 명령어와 데이터를 담고 있다.

### 아키텍처 기법

컴퓨터 설계자들은 프로세서가 더 빨리 작동하도록 만들기 위해 여러 가지 아키텍처 기법을 동원한다.

1. 인출과 실행 단계가 겹치도록 프로세서를 설계해서 명령어 여러 개가 다양한 단계에 걸쳐 진행(파이프 라이닝)
2. 명령어들이 서로 간섭하거나 의존하지 않는다면 다수의 명령어를 병렬적으로 실행하는 방법

### 트레이드 오프

사용 분야에 따라 프로세서를 설계할 때 다양한 종류의 트레이드 오프가 이루어진다.

1. 노트북
    - 노트북용 프로세서는 데스크톱용 프로세서보다 더 느리고 전력을 더 적게 쓰는 경향이 있다.
2. 휴대전화, 태블릿 PC 등 휴대성 기기
    - 크기, 무게, 전력에 제약이 노트북보다 훨씬 심함
    - 노트북과는 다르게 기존 설계를 약간 수정하는 것으로는 불충분
    - 영국 회사 ARM 홀딩스에서 라이선스를 관리하는 __ARM__ 이라는 프로세서 설계를 사용

## free_null

## [메모리 동적할당](https://velog.io/@emplam27/CS-%EA%B7%B8%EB%A6%BC%EC%9C%BC%EB%A1%9C-%EC%95%8C%EC%95%84%EB%B3%B4%EB%8A%94-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%8F%99%EC%A0%81%ED%95%A0%EB%8B%B9-Implicit-Explicit-Segregated-list-Allocator)

작성자가 예상하지 못하는, 사용자가 필요한 만큼의 메모리를 프로그램이 작동하는 도중에 할당받고자 할 때 사용하는 방법.  

동적 할당된 메모리는 힙(Heap)영역에 malloc과 free를 사용하여 할당되고 해제됨.

### 단편화(fragmentation)

쉽게 생각하면 사용하지 않거나 사용하지 못하는 메모리가 쌓여서 메모리 누수를 유발할 수 있는 경우들.

- 내부 단편화 : 필요한 메모리 보다 더 많은 메모리를 할당해서, 할당된 메모리 내에 비어있는 메모리가 발생하는 경우.
- 외부 단편화 : 어떠한 경우에도 할당하기에 너무 적은 공간만 남아 할당이 불가능한 메모리가 존재하는 경우

---

이러한 단편화 현상을 방지하는 효과적인 메모리 동적할당을 위한 정보들과 유의점들.

- 할당할 메모리의 __크기__ 는 얼마만큼인가?
- 할당할 메모리의 __위치__ 는 어디인가?
- 메모리를 할당할 수 있을 만큼의 __비어 있는 공간__ 은 어떻게 찾을 것인가?
- 해당 메모리 공간이 할당되어 있는지, 비어 있는지는 어떻게 알 것인가?
- 해제되어 비어 있는 메모리들을 어떻게 관리해서 __다시 할당__ 받을 수 있게 할 것인가?
- 공간의 효율성을 높일 수 있게 __단편화는 어떻게 해결__ 할 것인가?

> 이러한 유의점들을 효과적으로 알 수 있게 하여 메모리를 관리하고자 구조화 한 것이 __블록(block)__ 이라는 단위.

### 블록(block)

malloc 함수를 이용해 할당된 정보들이 저장되는 공간.

- Header : 블록의 시작점을 나타내는 부분
- Payload : 실제 정보들이 들어가는 부분
- Padding : 필요에 의해서 내부 단편화를 감수하고 할당해야 할 메모리보다 많은 메모리를 할당해주는 경우에 사용
- Footer : 블록의 끝점을 나타내는 부분.
- Previous or Next free block pointer : 할당이 해제된 블록의 포인터들을 저장, 이중 연결리스트의 형태로 할당 해제된 블록들 저장.

### implicit allocator(garbage collector)

garbage collector는 더 이상 프로그램에서 사용하지 않는 블록들(garbage)을 자동으로 반환하는 동적 저장장치 할당기.  
순차적으로 모든 블록을 검사하는 선형적인 방법으로, 마지막 검사한 블록을 시작으로 하는 next-fit 방식을 사용하면 좋다.  

---

응용은 C malloc 패키지 같은 명시적 할당기를 사용해서 malloc과 free를 호출해서 힙 블록을 할당하고 반환한다.  
더 이상 필요하지 않는 할당된 블록들을 반환하는 것은 응용 프로그램의 책무다.  
자동으로 힙 저장장치를 반납하는 과정을 가비지 컬렉션이라고 한다.  

---

가비지 컬렉션을 지원하는 시스템에서 응용 프로그램은 명시적으로 힙 블록을 할당하지만, 결코 명시적으로 이들을 반환하지 않는다. C 프로그램의 컨텍스트에서 생각해보면, 응용 프로그램은 malloc을 호출하지만 free를 호출하지 않는다. 대신, garbage collector가 주기적으로 garbage 블록을 식별하고 이 블록돌을 가용 리스트로 돌려주기 위해 적절하게 free를 호출한다.
