---
title: "W01_7_TIL"
date: 29/09/2022
categories: SWJG TIL
---
- [W01_30_1074_Z](https://my-coding-notes.tistory.com/411)
- [함수, 모듈, 패키지 차이점](https://losskatsu.github.io/programming/function-module-package/#)
- [선형대수와 통계학으로 배우는 머신러닝 with 파이썬](https://losskatsu.github.io/#)
- [라이브러리 >= 패키지 >= 모듈](https://aliencoder.tistory.com/20)
### 다짐. Today's Promise
- 

### 백트래킹
- [백트래킹 1](https://namu.wiki/w/%EB%B0%B1%ED%8A%B8%EB%9E%98%ED%82%B9)
- [백트래킹 2](https://chanhuiseok.github.io/posts/algo-23/)
- [백트래킹 3](https://chanhuiseok.github.io/posts/baek-1/)

- 백트래킹(backtracking)이란 해를 찾는 도중 해가 아니어서 막히면, 되돌아가서 다시 해를 찾아가는 기법을 말한다. 최적화 문제와 결정 문제를 푸는 방법. (brute force와 무엇이 다른지)



- 깊이 우선 탐색(DFS)
가능한 모든 경로(후보)를 탐색한다. 따라서, 불필요할 것 같은 경로를 사전에 차단하거나 하는 등의 행동이 없으므로 경우의 수를 줄이지 못한다.           

### [리스트 내장함수 시간 복잡도](https://velog.io/@kimwoody/Python-%EB%A6%AC%EC%8A%A4%ED%8A%B8%EC%99%80-%EB%94%95%EC%85%94%EB%84%88%EB%A6%AC%EC%9D%98-%EC%A3%BC%EC%9A%94-%EC%97%B0%EC%82%B0-%EC%8B%9C%EA%B0%84-%EB%B3%B5%EC%9E%A1%EB%8F%84)


|연산|시간 복잡도|설명|
|---|---|---|
|len(a)|O(1)|전체 요소의 개수를 리턴|
|a[i]|O(1)|인덱스 i의 요소를 가져온다|
|a[i:j]|O(k)|i부터 j까지 슬라이스의 길이만큼 k개의 요소를 가져옴. 이 경우 객체 k개에 대한 조회가 필요하므로 O(k)|
|elem in a|O(n)|elem 요소가 존재하는 지 확인. 처음부터 순차 탐색하므로 n만큼 시간이 소요됨.|
|a.count(elem)|O(n)|elem 요소의 개수를 리턴|
|a.index(elem)|O(n)|elem 요소의 인덱스를 리턴|
|a.append(elem)|O(1)|리스트 마지막에 elem 요소를 추가|
|a.pop()|O(1)|리스트 마지막 요소 추출. 스택의 연산|
|a.pop(0)|O(n)|리스트 첫번째 요소 추출. 큐의 연산. 전체 복사가 필요해서 O(n)|
|del a[i]|O(n)|i에 따라 다름. 최악의 경우 O(n)|
|a.sort()|O(nlogn)|정렬. 팀소트를 사용. 최선의 경우, O(n)|
|min(a),max(a)|O(n)|최솟값/최댓값을 계산하기 위해서는 전체를 선형탐색해야됨.|
|a.reverse()|O(n)|pop을 a 길이만큼 때림. 그래서 O(n)|


### 딕셔너리의 주요 연산 시간 복잡도 - O(1)
- 파이썬의 딕셔너리는 키/값 구조로 이뤄진 딕셔너리를 말한다.
- 파이썬 3.7+에서는 입력 순서가 유지되며, 내부적으로는 해시 테이블로 구현되어 있음.


|연산|시간 복잡도|설명|
|---|---|---|
|len(a)|O(1)|요소의 개수를 리턴|
|a[key]|O(1)|키를 조회하여 값을 리턴|
|a[key] = value|O(1)|키/값을 삽입|
|key in a|O(1)|딕셔너리에 키가 존재하는지 확인|



### 큐 queue
- queue는 스택과 같이 데이터를 임시 저장하는 자료구조.
- 선입선출 (FIFO, First-in-First-out)

|enqueue|queue에 데이터를 추가|
|dequeue|데이터를 꺼내는 작업|
|front|데이터를 꺼내는 쪽|
|rear|데이터를 넣는 쪽|

- 링 버퍼로 큐 구현하기



### 검색 알고리즘

- 선형 검색(순차 검색): 무작위로 늘어놓은 데이터 집합에서 검색
- 이진 검색: 일정한 규칙으로 늘어놓은 데이터 집합에서 아주 빠른 검색
- 해시법: 추가, 삭제가 자주 일어나는 데이터 집합에서 아주 빠른 검색
    - 체인법: 같은 해시값 데이터를 연결 리스트로 연결하는 방법
    - 오픈 주소법: 데이터를 위한 해시값이 충돌할 때 재해시하는 방법

- 데이터 집합이 있을 때 '검색만 잘되면 좋지!'라고 생각한다면, 계산 시간이 짧은 검색 알고리즘을 선택하면 됨.
- 그런데, 데이터 집합에서 검색뿐 아니라 데이터의 __추가, 삭제__ 등을 자주 수행해야 한다면 검색 이외의 작업에 들어가는 비용을 종합적으로 고려하여 알고리즘을 선택해야 됨. 즉, 해당 알고리즘을 고른 합리적인 이유가 있어야 됨.


### [iterable, sequence, iterator](https://planbs.tistory.com/entry/Python-Iterable-Sequence-Iterator)

- Iterable : 내장 함수 iter()에 대응되는 매직 메소드 __iter__() 가 정의되어 있는 객체
    list, tuple, dic, set, str
- Sequence : 내장 함수 len()에 대응되는 매직 메소드 __len__()과 __getitem__()이 정의되어 있는 객체
    python의 기본 iterable 타입들은 __iter__(), __len__(), __getitem__()메소드를 모두 구현하고 있으므로 sequence이자 iterable.
    list, tuple, dic, set
- Iterator : 내장 함수 next()에 대응되는 매직 메소드 __next__()가 정의되어 있는 객체
    list, dict, set, str, bytes, tuple, range

- 매직 메소드란(Magic method)
    파이썬에서 사용되는 특별한 메소드들을 의미
        special method 혹은 double underscore method라고 부르기도 함
    이미 파이썬 내에 정의되어 있고, 클래스 내부에서 매직 메소드들을 오버라이딩

- 파이썬에 존재하는 타입들은 모두 클래스
        
        print(int)      <class 'int'>
        print(str)      <class 'str'>
        print(float)    <class 'float'>
        print(list)     <class 'list'>
        print(tuple)    <class 'tuple'>
        print(dict)     <class 'dict'>

        print(dir(int)) 매직 메소드가 다 튀어나옴.

