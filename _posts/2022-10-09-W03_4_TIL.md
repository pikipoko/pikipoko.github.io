---
title: "W03_4_TIL"
date: 09/10/2022
categories: SWJG TIL
---

### TP, TD

- 물 많이 마시기
- 문제 한번씩 다 풀어보기
- 컴퓨터 시스템 공부

## 컴퓨터 시스템

모든 컴퓨터 시스템들은 유사한 기능을 수행하는 유사한 하드웨어와 소프트웨어 컴포넌트를 가지고 있다.

### 1.1 정보 = 비트 + 컨텍스트

- 텍스트 파일 : 아스키 문자들로만 이루어진 파일들
- 다른 모든 파일들은 바이너리 파일이라고 함.

---

- 모든 시스템 내부의 정보는 비트들로 표현된다.
- 시스템 내부의 정보 : 디스크 파일/ 메모리상의 프로그램/ 데이터/ 네트워크를 통해 전송되는 데이터.
- 서로 다른 객체들을 구분하는 유일한 방법은 이들을 바라보는 컨텍스트에 의해서다.

---

    [hello.c]

    #include <stdio.h>

    int main()
    {
        printf("Hello, world!\n");
        return 0;
    }

---

- C는 시스템 수준 프로그래밍을 위해 선택된 언어이다.

### 1.2 프로그램은 다른 프로그램에 의해 다른 형태로 번역된다

1. 전처리 단계 - Preprocessor(cpp)  
    - 본래의 c 프로그램을 #문자로 시작하는 디렉티브(directive)에 따라 수정  
        - #include <stdio.h>  
        - Preprocessor에게 시스템 헤더 파일인 stdio.h를 프로그램 문장에 직접 삽입하라고 지시  
    > hello.c - Preprocessor -> hello.i  

2. 컴파일 단계 - Compiler(ccl)  
    - 텍스트 파일 hello.i를 텍스트 파일 hello.s로 번역  
        - hello.s 파일 안에 어셈블리어 프로그램이 저장됨.  
    > hello.i - Compiler -> hello.s

3. 어셈블리 단계 - Assembler(as)  
    - hello.s를 기계어 인스트럭션으로 번역하고, 번역한 거를 재배치 가능 목적 프로그램의 형태로 묶어서 hello.o라는 목적 파일에 그 결과를 저장.
    > hello.s - Assembler -> hello.o

4. 링크 단계 - Linker(ld)
    - 이미 컴파일된 별도의 목적 파일인 printf.o와 hello.o를 결합시켜야 되는 과정을 수행함
        - C 라이브러리에 들어 있는 printf 함수를 호출했기 때문에 결합이 필요함.
    > (hello.o + printf.o) - Linker -> hello

### 1.3 컴파일 시스템이 어떻게 동작하는지 이해하는 것은 중요하다

- 프로그램의 성능을 최적화하기 위해
- 링크 에러를 이해하기 위해
- 보안 약점을 피하기 위해

### 1.4 프로세서는 메모리에 저장된 인스트럭션을 읽고 해석한다

#### shell

- 응용 프로그램
- Command Line Interpreter로 프롬프트를 출력하고 명령어 라인을 입력받아 그 명령을 실행
- 만일 명령어 라인이 내장 쉘 명령어가 아니면 쉘은 실행 파일의 이름으로 판단하고 그 파일을 로딩해서 실행해준다.

---

    linux> ./hello      -- 1
    hello, world        -- 2
    linux>              -- 3

    1 -- 위 경우는 ./hello가 내장 쉘 명령어가 아니기 때문에 실행파일의 이름으로 판단하고, 쉘이 ./hello를 로딩
    2 -- 실행하고 종료한 다음,
    3 -- 다음 입력 명령어 라인을 기다림

#### 1.4.1 시스템의 하드웨어 조직

1. 버스 (Buses)
    - 시스템 내를 관통하는 전기적 배선군
    - 컴포넌트(구성 요소) 간에 바이트 정보들을 전송
    - 일반적으로 워드(word)라고 하는 고정 크기의 바이트 단위로 데이터를 전송하도록 설계된다
        - 한 개의 워드를 구성하는 바이트 수는 시스템마다 보유하는 기본 시스템 변수다.

2. 입출력 장치
    - 시스템과 외부 세계와의 연결을 담당
    - 처음에, 실행가능 목적 프로그램(컴파일 시스템에 의해 만들어진 실행 파일) hello는 디스크에 저장되어 있다
    - 각 입출력 장치는 컨트롤러나 어댑터를 통해 입출력 버스와 연결된다.
    - 컨트롤러와 어댑터의 차이는 packaging에 있다.
        - 컨트롤러는 디바이스 자체가 칩셋이거나 시스템의 인쇄기판(마더보드)에 장착된다.
        - 어댑터는 마더보드의 슬롯에 장착되는 카드이다.
        > 둘다 입출력 버스와 입출력 장치들 간에 정보를 주고 받도록 해준다.

3. 메인 메모리
    - 프로세서가 프로그램을 실행하는 동안, 데이터와 프로그램을 모두 저장하는 임시 저장장치
        - 물리적으로 메인 메모리는 DRAM(Dynamic Random Access Memory) 칩들로 구성됨
        - 논리적으로 메모리는 연속적인 바이트들의 배열로, 각각 0부터 시작해서 고유의 주소(배열의 인덱스)를 가지고 있다.
    - 일반적으로 한 개의 프로그램을 구성하는 각 기계어 인스트럭션은 다양한 바이트 크기를 갖는다.

4. 프로세서 (주처리장치, CPU)
    - 메인 메모리에 저장된 인스트럭션들을 해독(실행)하는 엔진
    - 프로세서의 중심에는 워드 크기의 저장장치(혹은 레지스터)인 프로그램 카운터(PC)가 있다.
    - ALU는 새 데이터와 주소 값을 계산한다.
    - 레지스터 파일은 각각 고유의 이름을 갖는 워드 크기의 레지스터 집합으로 구성되어 있다.
    - 프로세서는 PC가 가리키는 메모리로부터 인스트럭션을 읽어오고, 이 인스트럭션에서 비트들을 해석하여 인스트럭션이 지정하는 간단한 동작을 실행하고, PC를 다음 인스트럭션 위치로 업데이트한다.
    - CPU가 실행하는 단순한 작업
        - 적재(Load), 저장(Store), 작업(Operate), 점프(Jump)
