---
title: "W03_4_TIL"
date: 09/10/2022
categories: SWJG TIL
---

### TP, TD

- 물 많이 마시기
- 문제 한번씩 다 풀어보기
- 컴퓨터 시스템 공부

## 컴퓨터 시스템

모든 컴퓨터 시스템들은 유사한 기능을 수행하는 유사한 하드웨어와 소프트웨어 컴포넌트를 가지고 있다.

### 1.1 정보 = 비트 + 컨텍스트

- 텍스트 파일 : 아스키 문자들로만 이루어진 파일들
- 다른 모든 파일들은 바이너리 파일이라고 함.

---

- 모든 시스템 내부의 정보는 비트들로 표현된다.
- 시스템 내부의 정보 : 디스크 파일/ 메모리상의 프로그램/ 데이터/ 네트워크를 통해 전송되는 데이터.
- 서로 다른 객체들을 구분하는 유일한 방법은 이들을 바라보는 컨텍스트에 의해서다.

---

    [hello.c]

    #include <stdio.h>

    int main()
    {
        printf("Hello, world!\n");
        return 0;
    }

---

- C는 시스템 수준 프로그래밍을 위해 선택된 언어이다.

### 1.2 프로그램은 다른 프로그램에 의해 다른 형태로 번역된다

1. 전처리 단계 - Preprocessor(cpp)  
    - 본래의 c 프로그램을 #문자로 시작하는 디렉티브(directive)에 따라 수정  
        - #include <stdio.h>  
        - Preprocessor에게 시스템 헤더 파일인 stdio.h를 프로그램 문장에 직접 삽입하라고 지시  
    > hello.c - Preprocessor -> hello.i  

2. 컴파일 단계 - Compiler(ccl)  
    - 텍스트 파일 hello.i를 텍스트 파일 hello.s로 번역  
        - hello.s 파일 안에 어셈블리어 프로그램이 저장됨.  
    > hello.i - Compiler -> hello.s

3. 어셈블리 단계 - Assembler(as)  
    - hello.s를 기계어 인스트럭션으로 번역하고, 번역한 거를 재배치 가능 목적 프로그램의 형태로 묶어서 hello.o라는 목적 파일에 그 결과를 저장.
    > hello.s - Assembler -> hello.o

4. 링크 단계 - Linker(ld)
    - 이미 컴파일된 별도의 목적 파일인 printf.o와 hello.o를 결합시켜야 되는 과정을 수행함
        - C 라이브러리에 들어 있는 printf 함수를 호출했기 때문에 결합이 필요함.
    > (hello.o + printf.o) - Linker -> hello

### 1.3 컴파일 시스템이 어떻게 동작하는지 이해하는 것은 중요하다

- 프로그램의 성능을 최적화하기 위해
- 링크 에러를 이해하기 위해
- 보안 약점을 피하기 위해

### 1.4 프로세서는 메모리에 저장된 인스트럭션을 읽고 해석한다

#### shell

- 응용 프로그램
- Command Line Interpreter로 프롬프트를 출력하고 명령어 라인을 입력받아 그 명령을 실행
- 만일 명령어 라인이 내장 쉘 명령어가 아니면 쉘은 실행 파일의 이름으로 판단하고 그 파일을 로딩해서 실행해준다.

---

    linux> ./hello      -- 1
    hello, world        -- 2
    linux>              -- 3

    1 -- ./hello가 내장 쉘 명령어가 아니기 때문에 실행파일의 이름으로 판단해서 ./hello를 로딩
    2 -- ./hello를 실행하고 종료
    3 -- 다음 입력 명령어 라인을 기다림

#### 1.4.1 시스템의 하드웨어 조직

1. 버스 (Buses)
    - 시스템 내를 관통하는 전기적 배선군
    - 컴포넌트(구성 요소) 간에 바이트 정보들을 전송
    - 일반적으로 워드(word)라고 하는 고정 크기의 바이트 단위로 데이터를 전송하도록 설계된다
        - 한 개의 워드를 구성하는 바이트 수는 시스템마다 보유하는 기본 시스템 변수다.

2. 입출력 장치
    - 시스템과 외부 세계와의 연결을 담당
    - 처음에, 실행가능 목적 프로그램(컴파일 시스템에 의해 만들어진 실행 파일) hello는 디스크에 저장되어 있다
    - 각 입출력 장치는 컨트롤러나 어댑터를 통해 입출력 버스와 연결된다.
    - 컨트롤러와 어댑터의 차이는 packaging에 있다.
        - 컨트롤러는 디바이스 자체가 칩셋이거나 시스템의 인쇄기판(마더보드)에 장착된다.
        - 어댑터는 마더보드의 슬롯에 장착되는 카드이다.
        > 둘다 입출력 버스와 입출력 장치들 간에 정보를 주고 받도록 해준다.

3. 메인 메모리
    - 프로세서가 프로그램을 실행하는 동안, 데이터와 프로그램을 모두 저장하는 임시 저장장치
        - 물리적으로 메인 메모리는 DRAM(Dynamic Random Access Memory) 칩들로 구성됨
        - 논리적으로 메모리는 연속적인 바이트들의 배열로, 각각 0부터 시작해서 고유의 주소(배열의 인덱스)를 가지고 있다.
    - 일반적으로 한 개의 프로그램을 구성하는 각 기계어 인스트럭션은 다양한 바이트 크기를 갖는다.

4. 프로세서 (주처리장치, CPU)
    - 메인 메모리에 저장된 인스트럭션들을 해독(실행)하는 엔진
    - 프로세서의 중심에는 워드 크기의 저장장치(혹은 레지스터)인 프로그램 카운터(PC)가 있다.
    - ALU는 새 데이터와 주소 값을 계산한다.
    - 레지스터 파일은 각각 고유의 이름을 갖는 워드 크기의 레지스터 집합으로 구성되어 있다.
    - 프로세서는 PC가 가리키는 메모리로부터 인스트럭션을 읽어오고, 이 인스트럭션에서 비트들을 해석하여 인스트럭션이 지정하는 간단한 동작을 실행하고, PC를 다음 인스트럭션 위치로 업데이트한다.
    - CPU가 실행하는 단순한 작업
        - 적재(Load), 저장(Store), 작업(Operate), 점프(Jump)

## 다익스트라(Dijkstra) 알고리즘

- 다이나믹 프로그래밍을 활용한 대표적인 최단 경로(Shortest Path) 탐색 알고리즘
- 특정한 하나의 정점에서 다른 모든 정점으로 가는 최단 경로를 알려줌
    > 다만, 음의 간선을 포함할 수 없음
- 다익스트라 알고리즘이 다이나믹 프로그래밍 문제인 이유는  
    > 최단 거리는 여러 개의 최단 거리로 이루어져 있기 때문입니다.
- 기본적으로 다익스트라는 하나의 최단 거리를 구할 때 그 이전까지 구했던 최단 거리 정보를 그대로 사용한다는 특징이 있다.

### 다익스트라 - 작동원리

1. 출발 노드를 설정
2. 출발 노드를 기준으로 각 노드의 최소 비용을 저장
3. 방문하지 않은 노드 중에서 가장 비용이 적은 노드를 선택
4. 해당 노드를 거쳐서 특정한 노드로 가는 경우를 고려하여 최소 비용을 갱신
5. 위 과정에서 3 ~ 4를 반복

## 위상 정렬 (Topology Sort) - queue

- __순서가 정해져있는 작업__ 을 차례로 수행해야 할 때 그 순서를 결정해주기 위해 사용하는 알고리즘
- 사이클이 없어야 수행 가능 (DAG여야 수행 가능)
    > DAG(Direct Acyclic Graph) : 순환하지 않는 그래프

---

- 진입차수(Indegree) : 특정한 노드로 들어오는 간선의 개수
- 진출차수(Outdegree) : 특정한 노드에서 나가는 간선의 개수

---

1. 진입차수가 0인 정점을 큐에 삽입
2. 큐가 빌때 까지 다음의 과정을 반복
    3. 큐에서 원소를 꺼내 연결된 모든 간선 제거
    4. 간선 제거 이후에 진입차수가 0이 된 정점을 큐에 삽입

> 모든 원소를 방문하기 전에 큐가 빈다면 사이클이 존재하는 것이고,  
> 모든 원소를 방문했다면 큐에서 꺼낸 순서가 위상 정렬의 결과

### 위상 정렬의 특징

- 위상 정렬은 DAG에 대해서만 수행할 수 있다.
- 위상 정렬에서는 여러 가지 답이 존재할 수 있다.
  - 한 단계에서 큐에 들어가는 원소가 2개 이상인 경우가 있다면 여러 가지 답이 존재
- 모든 원소를 방문하기 전에 큐가 빈다면 사이클이 존재한다고 판단할 수 있다.
  - 사이클에 포함된 원소 중에서 어떠한 원소도 큐에 들어가지 못한다.
- 스택을 활용한 DFS를 이용해 위상 정렬을 수행할 수 있다.

### 링크

- [Git - 브랜치 생성과 삭제, 체크아웃](https://mylko72.gitbooks.io/git/content/branch/checkout.html)
- [다익스트라(Dijkstra) Algorithm](https://m.blog.naver.com/ndb796/221234424646)
- [위상정렬(Topology Sort) - 큐](https://m.blog.naver.com/ndb796/221236874984)
- [아침산책1](https://velog.io/@letsbebrave/백준-21606-아침-산책-4i69dxml)
- [아침산책2](https://woonys.tistory.com/entry/정글사관학교-22일차-TIL-아침-산책with-Python-위상-정렬-알고리즘)
- [아침산책3](https://physics-07.tistory.com/9)
