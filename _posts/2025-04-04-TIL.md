---
title: "1일1코테 5day, leetcode 225. Implement Stack using Queues"
date: 2025-04-03
categories: TIL 5 leetcode_225_Implement_Stack_using_Queues CIL
---

오늘은 그래도 일찍 퇴근하여 기분 좋았다.  
집에 도착하자마자 밥 먹고 씻고와서 문제를 켰는데, 또 leetcode에다가 똑같은 문제처럼 보였다.  
엥 뭐지하고 링크가 잘못되었나? 해서 창을 껐다 켰는데도 똑같길래 디스코드 켜서 링크 다시 찾고 하다가 아! 얘는 스택 구현하는 거구나! 하고 그때부터 문제에 집중했다.  

어제와 동일한 형태로 코드를 작성하였고 문제를 통과하는 데에는 21분이 소요되었다.  

그렇게 어려운 문제는 아니었고, 어제 활용한 로직으로 조금만 변형하여 코드를 작성하여 복습한 느낌이다.  

대신 오늘 회사에서 배운 내용을 TIL로 작성해보려 한다.  

코테 느낌은 아니고, SQL 활용에 더 가깝다.  

쿼리에서 사용할 수 있는 유용한 함수를 배웠다고 보면 좋을 것 같다.  

---

## 회사에서 배운 내용

회사에서는 다음 주 화요일에 릴리즈 예정으로 3월 내내 바쁘다가 이제 서서히 릴리즈 마무리가 되어가는 분위기이다.  
여러 QA가 진행되는 가운데, 특정 모듈에서 수집하는 데이터와 실제 데이터가 다르다고 확인 요청을 받았고 오늘 분석을 진행하였다.  

디버깅 로그를 찍어나가면서 값이 왜 이렇게 되는지 분석을 하였는데, 데이터 수집 로직에 오류가 있는 것을 알게 되었다.  

### 데이터 수집 로직

기초 데이터가 수집되는 주기는 5초로 아래와 같이 A라는 테이블에 수집이 된다.  

> 20250404203000 - 3개  
> 20250404203005 - 2개  
> 20250404203010 - 5개  
> ...  

이 데이터들의 1분 평균을 B라는 다른 테이블에 저장한다.  

---

5초마다 쌓이는 데이터들을 실행하고 있는 프로그램의 메모리에 들고 있기에는 메모리 부하가 생길 수 있어서,  
메모리에 들고있는 대신 20초 마다 수집 쿼리를 실행하는 방식을 택했다.  

쿼리 내에서는 이전에 수집했던 데이터이면 수집하지 않게끔 `where` 조건절을 걸어주고  
`avg()`와 `group by`를 이용하여 평균값으로 데이터를 가져온다.  

---

```SQL
select log_time,
    avg_data
from
    (select substr(logtime, 1, 12) as log_time
        round(avg(data), 2) as avg_data
    from B
        where logtime > ?
        group by log_time
    ) a
```

---

이 쿼리를 실행할 때, 시간 값을 초는 자르고 있으면서 20초 마다 수집 쿼리를 수행하기 때문에 문제가 있었다.

예를 들면, 00분 20초에 수집 쿼리를 실행하여 `00분 00초 ~ 00분 20초 까지의 평균값을 조회`하는데 log_time 값은 초를 자르기 때문에  
모듈에서는 00분 평균 데이터가 들어온 것으로 인식하여 00분 대의 평균값으로 데이터가 수집되고 있던 것이다.  

데이터가 수집되고 나면, 이 시간대는 수집을 완료했기 때문에,  
다음에 쿼리를 실행할 때, 7번째 줄 `where logtime > ?` 조건절에 ?값을 00분으로 걸어서 00분 데이터는 더이상 수집되지 않고 있었다.  

다음 주 화요일 이전에 수정 후 QA가 완료되어야 되기 때문에, 모듈 내부 로직을 뜯어고치는 건 위험하다고 생각하였고, 팀장님과 전무님께 이 상황을 말씀드렸다.   

전무님이 아이디어를 주셨는데, 모듈 수정은 하지 말고 수집 쿼리에 `ROW_NUMBER`를 조건절로 추가하는 것이었다.  

즉, `ROW_NUMBER`가 1인, 제일 최신 분의 값은 조회 결과에 포함되지 않게 하자는 것이었다.  

설명을 편하게 하기 위해 시간 형식은 HHMM, HHMMSS로 작성하겠다.(분, 초 를 매번 작성하기 조금 귀찮고 오히려 읽기 힘들다고 생각했다.)  

---

203100에 203000 ~ 203100의 평균 데이터를 수집 완료했고 이제 20초마다 쿼리를 실행한다고 해보자.  
`where logtime > ?` 조건절은 이제 `where logtime > 2030`가 될 것이다.  

그 다음에 수집할 데이터는 203100 ~ 203200의 평균 데이터이다.  
하지만 다음에 수집 쿼리가 실행될 때는 203120 으로 203100 ~ 203120 데이터의 평균값으로,  
아직 203120 ~ 203200의 데이터가 어떤지 모른다. 203200이 되서야 203100 ~ 203200 평균 값을 알 수 있다.  

`group by log_time`, 즉 분까지의 시간으로 group by되어 있기 때문에 203120 에 쿼리로 조회해오는 시간은 2031이다.    
따라서 여기서 `ROW_NUMBER > 1`를 조건절로 걸어서 2031은 쿼리 결과로 조회해오지 못하게 하는 것이다.  

203200이 되면, 조회해오는 시간은 이제 2031, 2032로 `ROW_NUMBER > 1`조건절에 의해 2032는 제외되고, 2031의 데이터가 수집된다!

최종 완성된 쿼리는 아래 형태이다.  

---

```SQL
select log_time,
    avg_data
from
    (select log_time,
        avg_data,
        (ROW_NUMBER() OVER()) as rownum
    from
        (select substr(logtime, 1, 12) as log_time
            round(avg(data), 2) as avg_data
        from A
            where logtime > ?
            group by log_time
        ) t1
    ) t2
where t2.rownum > 1
```

---

### 문제 링크

- [leetcode, 225. Implement Stack using Queues](https://leetcode.com/problems/implement-stack-using-queues/description/)
