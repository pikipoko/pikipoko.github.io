---
title: "WIL6"
date: 29/10/2022
categories: SWJG
---

## mm_implicit.c

<details>
<summary>bit operator</summary>
<div markdown="1">

    &       AND
    |       OR
    ^       XOR
    ~       모든 비트 반전
    <<      왼쪽으로 이동
    >>      오른쪽으로 이동

</div>
</details>

<details>
<summary>define</summary>
<div markdown="1">

    ALIGNMENT               8
    ALIGN(size)             (((size) + (ALIGNMENT - 1)) & ~0x7)
    SIZE_T_SIZE             (ALIGN(sizeof(size_t)))

    WSIZE                   4
    DSIZE                   8
    CHUNKSIZE               (1<<12)

    MAX(x, y)               ((x) > (y) ? (x) : (y))
    PACK(size, alloc_bit)   ((size) | (alloc_bit))

    GET(p)                  (*(unsigned int *) (p))
    PUT(p, val)             (*(unsigned int *) (p) = (val))

    GET_SIZE(p)             (GET(p) & ~0x7)
    GET_ALLOC(p)            (GET(p) & 0x1)

    HDRP(bp)                ((char *)(bp) - WSIZE)
    FTRP(bp)                ((char *)(bp) + GET_SIZE(HDRP(bp)) - DSIZE)

    NEXT_BLKP(bp)           ((char *)(bp) + GET_SIZE(((char *)(bp) - WSIZE)))
    PREV_BLKP(bp)           ((char *)(bp) - GET_SIZE(((char *)(bp) - DSIZE)))

</div>
</details>

<details>
<summary>function</summary>
<div markdown="1">

    brk         break
    sbrk        space break - mem_sbrk(asize) = get more memory size
    fblk        free block
    bp          block pointer
    epl         epilogue
    rtn         return

    int mm_init (void);                                 init padding, prologue(header, footer), epilogue header / extend heap by CHUNKSIZE
    void *mm_malloc (size_t size);                      search fblk and allocate size(set hdr, ftr), not enough heap > sbrk
    void mm_free (void *ptr);                           make allocated blk to free blk
    void *mm_realloc(void *ptr, size_t size);           change size
    
    static void *extend_heap(size_t words);             sbrk by (even)words / init new fblk(hdr, ftr) and epl_hdr / coalesce fblk, prev, next
    static void *coalesce(void *bp);                    coalesce bp, prev, next by case 4
    static void place(void *bp, size_t asize);          put blk's hdr, ptr of asize, make the rest of blk to freeblk 
    static void *find_fit(size_t asize);                driver of first, next, best fit func
    static void *first_fit(size_t asize);               search from start to end, rtn the first blk to fit
    static void *next_fit(size_t asize);                search from last search_end to end, rtn the first blk to fit
    static void *best_fit(size_t asize);                search from start to end, rtn the smallest blk to fit

</div>
</details>

next_bp 갱신

## mm_explicit.c

묵시적 할당기는 블록 할당 시간이 전체 힙 블록의 수에 비례하기 때문에 묵시적 가용 리스트는 범용 할당기에는 적합하지 않다. 
더 좋은 방법은 가용 블록들을 일종의 명시적 자료구조로 구성하는 것. (이중 연결 리스트) 
정의에 의해 가용 블록의 본체는 프로그램에서 필요하지 않기 때문에 이 자료구조를 구현하는 포인터들은 가용 블록의 본체 내에 저장될 수 있다. 
힙은 각 가용 블록 내에 pred(predecessor)와 succ(successor) 포인터를 포함하는 이중 연결 가용 리스트로 구성될 수 있다. 
doubly linked list를 사용하면 first fit 할당 시간을 전체 블록 수에 비례하는 것에서 가용 블록의 수에 비례하는 것으로 줄일 수 있다. 
그렇지만, 블록을 반환하는 시간은 가용 리스트 내에서 블록을 정렬하는 정책을 어떤 것을 선택하는 가에 따라 비례하거나 상수 시간을 가질 수 있다. 
