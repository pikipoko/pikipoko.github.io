---
title: "W03_WIL_221006~221013"
date: 13/10/2022
categories: SWJG WIL
---

## deque method

- 아주 성능 좋은 LIST-LIKE method

---

| q = deque()           | from collections import deque     |
| --------------------- | --------------------------------- |
| __q.append(item)__    | append right                      |
| q.appendleft(item)    | append left                       |
| __q.pop()__           | pop right item                    |
| __q.popleft()__       | pop left item                     |
| q.extend(array)       | append array into q's right       |
| q.extendleft(array)   | append array into q's left        |
| q.remove(item)        | find item and remove              |
| q.rotate(int)         | rotate q by int                   |

## 조건문, if문

    if False:
        print('False')
    if True:
        print('True)
            >> True

    if -1:
        print('-1')
            >> -1

    if 1:
        print('1')
            >> 1

## mutable, immutable 자료형

| --------- | ------------------------- |
| mutable   | int, float, str, tuple    |
| immutable | list, dict                |

## strip(), split()

- strip() : 문자열의 양 끝에서 공백, 개행을 제거하는 함수
- split() : parameter(default : 공백)을 기준으로 분할된 리스트를 만드는 함수

---

    strip()
        " abcde " >> "abcde"

        tmp = list(map(int, input().strip()))
            # 101111 입력
        print(tmp)
            # [1, 0, 1, 1, 1, 1]

    split()
        "a b c de f" >> ['a', 'b', 'c', 'de', 'f']
    
        tmp = list(map(int, input().split()))
            # 101111 입력
        print(tmp)
            # [101111]

## USB

- Universal Serial Bus, 범용 직렬 버스

## Abstraction, 추상화

- 물리적인 구현의 세부사항을 숨기고 핵심적인 개념 또는 기능을 간추려 내는 것을 말함

## graph

> __노드__ 와 노드 간을 연결하는 __간선__ 으로 구성된 자료 구조

## tree

> 두 개의 노드 사이에 반드시 1개의 경로만을 가지며, 사이클이 존재하지 않는 방향 그래프

### graph와 tree

|               | 그래프                    | 트리                          |
| ------------- | ------------------------ | ----------------------------- |
| 방향성        | 방향, 무방향, 양방향      | 방향                          |
| 사이클        | 순환, 비순환, 자기순환    | 비순환                        |
| 루트노드      | 루트 개념 없음            | 한 개의 루트 존재             |
| 부모-자식     | 부모/자식 개념 없음       | 1개의 부모노드(루트 제외)     |
| 모델          | 네트워크 모델             | 계층 모델                     |
| 간선 수       | 자유                      | N-1개                         |

### ordered tree, unordered tree

- ordered tree: 형제 노드의 순서관계 O
- unordered tree: 형제 노드의 순서관계 X

## ordered tree의 search

- BFS(Breadth First Search)
  - 폭 우선 검색, 가로 검색, 수평 검색
  - 한 레벨에서 검색을 마치면 다음 레벨로 내려가는 방법

- DFS(Depth First Search)
  - 세로 검색, 수직 검색
  - leaf에 도달할 때 까지 아래쪽으로 내려가면서 검색하는 것을 우선하는 방법
    - preorder      : node > left child > right child
    - inorder       : left child > node > right child
    - postorder     : left child > right child > node

## spanning tree, 신장 트리

그래프 내의 모든 정점을 포함하는 트리  
spanning tree는 트리의 특수한 형태로 모든 정점들이 연결되어 있어야 하고, 사이클을 포함해서는 안된다

> spanning tree는 그래프에 있는 n개의 정점을 정확히 (n-1)개의 간선으로 연결한다

## MST(Minimal Spanning Tree), 최소 신장 트리

- 특징
  1. 간선의 가중치의 합이 최소여야 한다.
  2. n개의 정점을 가지는 그래프에 대해 반드시 (n-1)개의 간선만을 사용해야 한다.
  3. 사이클이 포함되어서는 안된다.

- 사용 사례 : 도로 건설, 전기 회로, 통신, 배관

- 구현 방법(greedy method)
  1. Kruskal    크루스칼
  2. Prim       프림
  3. Boruvka    보루프카

## Kruskal Algorithm

> 이전 단계에서 만들어진 신장 트리와는 상관없이 무조건 최소 간선만을 선택하는 방법

1. 그래프의 간선들을 가중치의 오름차순으로 정렬
2. 정렬된 간선 리스트에서 순서대로 사이클을 형성하지 않는 간선을 선택
    - 즉, 가장 낮은 가중치를 먼저 선택
    - 사이클을 형성하는 간선 제외
3. 해당 간선을 현재의 MST의 집합에 추가

## Prim Alogrithm

> 이전 단계에서 만들어진 신장 트리를 확장하는 방법

1. 시작 단계에서는 시작 정점만이 MST 집합에 포함됨
2. 앞 단계에서 만들어진 MST 집합에 인접한 정점들 중에서 최소 간선으로 연결된 정점을 선택하여 트리 확장
    - 즉, 가장 낮은 가중치를 먼저 선택
3. 위의 과정을 트리가 N-1 개의 간선을 가질 때까지 반복

### [Kruskal vs Prim](https://velog.io/@fldfls/%EC%B5%9C%EC%86%8C-%EC%8B%A0%EC%9E%A5-%ED%8A%B8%EB%A6%AC-MST-%ED%81%AC%EB%A3%A8%EC%8A%A4%EC%B9%BC-%ED%94%84%EB%A6%BC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98)

> 간선의 개수가 작은 경우에는 Kruskal, 간선의 개수가 많은 경우에는 Prim을 사용하는 게 성능 측면에서 좋다.

- Kruskal
  - 간선 위주의 알고리즘
  - 최소 비용의 간선을 차례로 대입하면서 트리를 구성하기 때문에 사이클 검사를 항상 해야 한다.
  - 간선을 기준으로 정렬하는 과정이 오래 걸린다.

- Prim
  - 정점 위주의 알고리즘
  - 시작점을 정하고, 시작점에서 가까운 정점을 선택하면서 트리를 구성하므로 사이클이 생기지 않아 사이클 검사를 안해도 된다.
  - 최소 거리의 정점을 찾는 부분에서 자료 구조의 성능에 영향을 받는다.

## Disjoint Set

- 서로 중복되지 않는 부분 집합들로 나눠진 원소들에 대한 정보를 저장하고 조작하는 자료 구조
- 즉, 공통 원소가 없는, 즉 __상호 배타적__ 인 부분 집합들로 나눠진 원소들에 대한 자료구조

> 서로소 집합 자료구조

- union(x, y)
  - 합하기
  - x가 속한 집합과 y가 속한 집합을 합친다.
  - 즉, x와 y가 속한 두 집합을 합치는 연산

- find(x)
  - 찾기
  - x가 속한 집합의 대표값(루트 노드 값)을 반환한다.
  - 즉, x가 어떤 집합에 속해 있는지 찾는 연산

## Dijkstra Algorithm

- 다이나믹 프로그래밍을 활용한 대표적인 최단 경로(Shortest Path) 탐색 알고리즘
  - 다이나믹 프로그래밍인 이유는 최단 거리는 여러 개의 최단 거리로 이루어져 있기 때문
- 특정한 하나의 정점에서 다른 모든 정점으로 가는 최단 경로를 알려줌
- 기본적으로 다익스트라는 하나의 최단 거리를 구할 때 그 이전까지 구했던 최단 거리 정보를 그대로 사용한다.

> __음의 간선을 포함할 수 없음__

### Dijkstra 작동원리

1. 출발 노드를 설정
2. 출발 노드를 기준으로 각 노드의 최소 비용을 저장
3. 방문하지 않은 노드 중에서 가장 비용이 적은 노드를 선택
4. 해당 노드를 거쳐서 특정한 노드로 가는 경우를 고려하여 최소 비용을 갱신
5. 3 ~ 4 를 반복

## 위상 정렬(Topology Sort) - queue

- __순서가 정해져 있는 작업__ 의 순서를 결정해주기 위해 사용하는 알고리즘
- DAG여야 수행 가능
  - Direct Acyclic Graph : 순환하지 않는 그래프

- 진입차수(Indegree) : 특정한 노드로 들어오는 간선의 개수
- 진출차수(Outdegree) : 특정한 노드에서 나가는 간선의 개수

---

1. 진입차수가 0인 정점을 큐에 삽입
2. 큐가 빌때까지 다음의 과정 반복
    1. 큐에서 원소를 꺼내 연결된 모든 간선 제거
    2. 간선 제거 이후에 진입차수가 0이 된 정점을 큐에 삽입

> 모든 원소를 방문하기 전에 큐가 빈다면 사이클이 존재
> 모든 원소를 방문했다면 큐에서 꺼낸 결과가 위상 정렬의 결

### 링크

- [union, find algorithm](https://gmlwjd9405.github.io/2018/08/31/algorithm-union-find.html)
