---
title: "W03_WIL_221006~221013"
date: 13/10/2022
categories: SWJG WIL
---

## deque method

- 아주 성능 좋은 LIST-LIKE method

---

| q = deque()           | from collections import deque     |
| --------------------- | --------------------------------- |
| __q.append(item)__    | append right                      |
| q.appendleft(item)    | append left                       |
| __q.pop()__           | pop right item                    |
| __q.popleft()__       | pop left item                     |
| q.extend(array)       | append array into q's right       |
| q.extendleft(array)   | append array into q's left        |
| q.remove(item)        | find item and remove              |
| q.rotate(int)         | rotate q by int                   |

## 조건문, if문

    if False:
        print('False')
    if True:
        print('True)
            >> True

    if -1:
        print('-1')
            >> -1

    if 1:
        print('1')
            >> 1

## mutable, immutable 자료형

| --------- | ------------------------- |
| mutable   | int, float, str, tuple    |
| immutable | list, dict                |

## strip(), split()

- strip() : 문자열의 양 끝에서 공백, 개행을 제거하는 함수
- split() : parameter(default : 공백)을 기준으로 분할된 리스트를 만드는 함수

---

    strip()
        " abcde " >> "abcde"

        tmp = list(map(int, input().strip()))
            # 101111 입력
        print(tmp)
            # [1, 0, 1, 1, 1, 1]

    split()
        "a b c de f" >> ['a', 'b', 'c', 'de', 'f']
    
        tmp = list(map(int, input().split()))
            # 101111 입력
        print(tmp)
            # [101111]

## USB

- Universal Serial Bus, 범용 직렬 버스

## Abstraction, 추상화

- 물리적인 구현의 세부사항을 숨기고 핵심적인 개념 또는 기능을 간추려 내는 것을 말함

## graph

> __노드__ 와 노드 간을 연결하는 __간선__ 으로 구성된 자료 구조

## tree

> 두 개의 노드 사이에 반드시 1개의 경로만을 가지며, 사이클이 존재하지 않는 방향 그래프

### graph와 tree

|               | 그래프                    | 트리                          |
| ------------- | ------------------------ | ----------------------------- |
| 방향성        | 방향, 무방향, 양방향      | 방향                          |
| 사이클        | 순환, 비순환, 자기순환    | 비순환                        |
| 루트노드      | 루트 개념 없음            | 한 개의 루트 존재             |
| 부모-자식     | 부모/자식 개념 없음       | 1개의 부모노드(루트 제외)     |
| 모델          | 네트워크 모델             | 계층 모델                     |
| 간선 수       | 자유                      | N-1개                         |

### ordered tree, unordered tree

- ordered tree: 형제 노드의 순서관계 O
- unordered tree: 형제 노드의 순서관계 X

## ordered tree의 search

- BFS(Breadth First Search)
  - 폭 우선 검색, 가로 검색, 수평 검색
  - 한 레벨에서 검색을 마치면 다음 레벨로 내려가는 방법

- DFS(Depth First Search)
  - 세로 검색, 수직 검색
  - leaf에 도달할 때 까지 아래쪽으로 내려가면서 검색하는 것을 우선하는 방법
    - preorder      : node > left child > right child
    - inorder       : left child > node > right child
    - postorder     : left child > right child > node

## spanning tree, 신장 트리

그래프 내의 모든 정점을 포함하는 트리  
spanning tree는 트리의 특수한 형태로 모든 정점들이 연결되어 있어야 하고, 사이클을 포함해서는 안된다

> spanning tree는 그래프에 있는 n개의 정점을 정확히 (n-1)개의 간선으로 연결한다

## MST(Minimal Spanning Tree), 최소 신장 트리

- 특징
  1. 간선의 가중치의 합이 최소여야 한다.
  2. n개의 정점을 가지는 그래프에 대해 반드시 (n-1)개의 간선만을 사용해야 한다.
  3. 사이클이 포함되어서는 안된다.

- 사용 사례 : 도로 건설, 전기 회로, 통신, 배관

- 구현 방법(greedy method)
  1. Kruskal    크루스칼
  2. Prim       프림
  3. Boruvka    보루프카

## Kruskal Algorithm

> 이전 단계에서 만들어진 신장 트리와는 상관없이 무조건 최소 간선만을 선택하는 방법

1. 그래프의 간선들을 가중치의 오름차순으로 정렬
2. 정렬된 간선 리스트에서 순서대로 사이클을 형성하지 않는 간선을 선택
    - 즉, 가장 낮은 가중치를 먼저 선택
    - 사이클을 형성하는 간선 제외
3. 해당 간선을 현재의 MST의 집합에 추가

## Prim Alogrithm

> 이전 단계에서 만들어진 신장 트리를 확장하는 방법

1. 시작 단계에서는 시작 정점만이 MST 집합에 포함됨
2. 앞 단계에서 만들어진 MST 집합에 인접한 정점들 중에서 최소 간선으로 연결된 정점을 선택하여 트리 확장
    - 즉, 가장 낮은 가중치를 먼저 선택
3. 위의 과정을 트리가 N-1 개의 간선을 가질 때까지 반복

### [Kruskal vs Prim](https://velog.io/@fldfls/%EC%B5%9C%EC%86%8C-%EC%8B%A0%EC%9E%A5-%ED%8A%B8%EB%A6%AC-MST-%ED%81%AC%EB%A3%A8%EC%8A%A4%EC%B9%BC-%ED%94%84%EB%A6%BC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98)

> 간선의 개수가 작은 경우에는 Kruskal, 간선의 개수가 많은 경우에는 Prim을 사용하는 게 성능 측면에서 좋다.

- Kruskal
  - 간선 위주의 알고리즘
  - 최소 비용의 간선을 차례로 대입하면서 트리를 구성하기 때문에 사이클 검사를 항상 해야 한다.
  - 간선을 기준으로 정렬하는 과정이 오래 걸린다.

- Prim
  - 정점 위주의 알고리즘
  - 시작점을 정하고, 시작점에서 가까운 정점을 선택하면서 트리를 구성하므로 사이클이 생기지 않아 사이클 검사를 안해도 된다.
  - 최소 거리의 정점을 찾는 부분에서 자료 구조의 성능에 영향을 받는다.

## Disjoint Set

- 서로 중복되지 않는 부분 집합들로 나눠진 원소들에 대한 정보를 저장하고 조작하는 자료 구조
- 즉, 공통 원소가 없는, 즉 __상호 배타적__ 인 부분 집합들로 나눠진 원소들에 대한 자료구조

> 서로소 집합 자료구조

- union(x, y)
  - 합하기
  - x가 속한 집합과 y가 속한 집합을 합친다.
  - 즉, x와 y가 속한 두 집합을 합치는 연산

- find(x)
  - 찾기
  - x가 속한 집합의 대표값(루트 노드 값)을 반환한다.
  - 즉, x가 어떤 집합에 속해 있는지 찾는 연산

## Dijkstra Algorithm

- 다이나믹 프로그래밍을 활용한 대표적인 최단 경로(Shortest Path) 탐색 알고리즘
  - 다이나믹 프로그래밍인 이유는 최단 거리는 여러 개의 최단 거리로 이루어져 있기 때문
- 특정한 하나의 정점에서 다른 모든 정점으로 가는 최단 경로를 알려줌
- 기본적으로 다익스트라는 하나의 최단 거리를 구할 때 그 이전까지 구했던 최단 거리 정보를 그대로 사용한다.

> __음의 간선을 포함할 수 없음__

### Dijkstra 작동원리

1. 출발 노드를 설정
2. 출발 노드를 기준으로 각 노드의 최소 비용을 저장
3. 방문하지 않은 노드 중에서 가장 비용이 적은 노드를 선택
4. 해당 노드를 거쳐서 특정한 노드로 가는 경우를 고려하여 최소 비용을 갱신
5. 3 ~ 4 를 반복

## 위상 정렬(Topology Sort) - queue

- __순서가 정해져 있는 작업__ 의 순서를 결정해주기 위해 사용하는 알고리즘
- DAG여야 수행 가능
  - Direct Acyclic Graph : 순환하지 않는 그래프

- 진입차수(Indegree) : 특정한 노드로 들어오는 간선의 개수
- 진출차수(Outdegree) : 특정한 노드에서 나가는 간선의 개수

---

1. 진입차수가 0인 정점을 큐에 삽입
2. 큐가 빌때까지 다음의 과정 반복
    1. 큐에서 원소를 꺼내 연결된 모든 간선 제거
    2. 간선 제거 이후에 진입차수가 0이 된 정점을 큐에 삽입

> 모든 원소를 방문하기 전에 큐가 빈다면 사이클이 존재
> 모든 원소를 방문했다면 큐에서 꺼낸 결과가 위상 정렬의 결과

---

## 컴퓨터 시스템

모든 컴퓨터 시스템들은 유사한 기능을 수행하는 유사한 하드웨어와 소프트웨어 컴포넌트를 가지고 있다.

---

> 컴퓨터 시스템이 동작하려면 하드웨어 뿐만 아니라 소프트웨어도 필요하다

- 컴퓨터를 구성하는 장치인 __하드웨어__ 는 물리적인 실체로 컴퓨터에서 사용되는 정보들을 처리, 전송, 저장하고 전송 통로를 제공한다
- 하드웨어가 특정 작업을 수행하도록 제어 신호들을 제공하는 일련의 부호들(codes) 혹은 명령어들(instructions)의 집합을 __소프트웨어__ 라 한다
- __펌웨어(Firmware)__ 는 소프트웨어를 하드웨어화한 것으로 하드웨어와 소프트웨어의 중간단계에 해당되어 미들웨어(Middleware)라고도 한다

### 1.1 정보 = 비트 + 컨텍스트

아스키 문자들로만 이루어진 파일들을 __텍스트 파일__ 이라고 하고, 다른 모든 파일들은 바이너리 파일이라고 함

---

- 모든 시스템 내부의 정보는 비트들로 표현됨
- 시스템 내부의 정보 : 디스크 파일 / 메모리상의 프로그램 / 데이터 / 네트워크를 통해 전송되는 데이터
- 서로 다른 객체들을 구분하는 유일한 방법은 이들을 바라보는 __컨텍스트__ 에 의해서다

---

    [hello.c]

    #include <stdio.h>

    int main()
    {
        printf("Hello, world!\n");
        return 0
    }

### 1.2 프로그램은 다른 프로그램에 의해 다른 형태로 번역된다

1. 전처리 단계 - Preporcessor(cpp)
    - 본래의 c프로그램을 #문자로 시작하는 디렉티브(directive)에 따라 수정
        - #include
        - Preprocessor에게 시스템 헤더 파일인 stdio.h를 프로그램 문장에 직접 삽입하라고 지시
    > hello.c - Preprocessor -> hello.i

2. 컴파일 단계 - Compiler(ccl)
    - 텍스트 파일 hello.i를 텍스트 파일 hello.s로 번역
        - hello.s 파일 안에 어셈블리어 프로그램이 저장됨
    > hello.i - Compiler -> hello.s

3. 어셈블리 단계 - Assembler(as)
    - hello.s를 기계어 인스트럭션으로 번역하고, 번역한 거를 재배치 가능 목적 프로그램의 형태로 묶어서 hello.o라는 목적 파일에 그 결과를 저장
    > hello.s - Assembler -> hello.o

4. 링크 단계 - Linker(ld)
    - 이미 컴파일된 별도의 목적 파일인 printf.o와 hello.o를 결합시켜야 되는 과정을 수행
    - C 라이브러리에 들어 있는 printf 함수를 호출했기 때문에 결합이 필요
    > (hello.o + printf.o) - Linker -> hello

### 1.4 프로세서는 메모리에 저장된 인스트럭션을 읽고 해석한다

#### shell

- 응용 프로그램
- Command Line Interpreter로 프롬프트를 출력하고 명령어 라인을 입력받아 그 명령을 실행
- 만일 명령어 라인이 내장 쉘 명령어가 아니면 쉘은 실행 파일의 이름으로 판단하고 그 파일을 로딩해서 실행해준다

---

    linux> ./hello              -- 1
    hello, world                -- 2
    linux>                      -- 3

    1 - ./hello가 내장 쉘 명령어가 아니기 때문에 실행파일의 이름으로 판단해서, ./hello를 로딩
    2 - ./hello를 실행하고 종료
    3 - 다음 입력 명령어 라인을 기다림

#### 1.4.1 시스템의 하드웨어 조직

1. 버스(Buses)
    - 시스템 내를 관통하는 전기적 배선군
    - 컴포넌트(구성 요소)간에 바이트 정보들을 전송
    - 일반적으로 워드(word)라고 하는 고정 크기의 바이트 단위로 데이터를 전송하도록 설계됨
        - 한 개의 워드를 구성하는 바이트 수는 시스템마다 보유하는 기본 시스템 변수

2. 입출력 장치
    - 시스템과 외부 세계와의 연결을 담당
    - 처음에, 실행가능 목적 프로그램(컴파일 시스템에 의해 만들어진 실행 파일) hello는 디스크에 저장되어 있다
    - 각 입출력 장치는 컨트롤러나 어댑터를 통해 입출력 버스와 연결된다
    - 컨트롤러와 어댑터의 차이는 packaging에 있다
        - 컨트롤러는 디바이스 자체가 칩셋이거나 시스템의 인쇄기판(마더보드)에 장착된다
        - 어댑터는 마더보드의 슬롯에 장착되는 카드이다
    > 둘다 입출력 버스와 입출력 장치들 간에 정보를 주고 받도록 해준다.

3. 메인 메모리
    - 프로세서가 프로그램을 실행하는 동안, 데이터와 프로그램을 모두 저장하는 임시 저장장치
        - 물리적으로 메인 메모리는 DRAM(Dynamic Random Access Memory) 칩들로 구성됨
        - 논리적으로 메모리는 연속적인 바이트들의 배열로, 각각 0부터 시작해서 고유의 주소(배열의 인덱스)를 가지고 있다
    - 일반적으로 한 개의 프로그램을 구성하는 각 기계어 인스트럭션은 다양한 바이트 크기를 갖는다

4. 프로세서 (주처리장치, CPU)
    - 메인 메모리에 저장된 인스트럭션들을 해독(실행)하는 엔진
    - 프로세서의 중심에는 워드 크기의 저장장치(혹은 레지스터)인 프로그램 카운터(PC)가 있다
    - ALU는 새 데이터와 주소 값을 계산
    - 레지스터 파일은 각각 고유의 이름을 갖는 워드 크기의 레지스터 집합으로 구성되어 있다
    - 프로세서는 PC가 가리키는 메모리로부터 인스트럭션을 읽어오고, 이 인스트럭션에서 비트들을 해석하여 인스트럭션이 지정하는 간단한 동작을 실행하고, PC를 다음 인스트럭션 위치로 업데이트한다
    - CPU가 실행하는 단순한 작업
        - 적재(Load), 저장(Store), 작업(Operate), 점프(Jump)

### 1.5 캐시가 중요하다

시스템은 정보를 한 곳에서 다른 곳으로 이동시키는 일에 많은 시간을 보낸다

- hello 프로그램의 기계어 인스트럭션들은 본래 하드디스크에 저장되어 있다

1. 프로그램이 로딩될 때 이 인스트럭션들은 메인 메모리로 복사된다
2. 프로세서가 프로그램을 실행할 때 인스트럭션들은 메인 메모리에서 프로세서로 복사된다
3. 'Hello, world\n' 데이터 스트링도 본래는 디스크에 저장되어 있었지만, 메인 메모리로 복사되었다가 디스플레이 장치로 복사된다

프로그래머의 관점에서 보면, 이러한 여러 복사 과정들(1, 2, 3)이 프로그램의 "실제 작업"을 느리게 하는 오버헤드다.  
시스템 설계자들의 주요 목적은 이러한 복사과정들을 가능한 빠르게 동작하도록 하는 것이다.

---

- 물리학의 법칙 때문에 더 큰 저장장치들은 보다 작은 저장장치들보다 느린 속도를 갖는다
- 더 빠른 장치들은 더 느린 장치들보다 만드는데 더 많은 비용이 든다
  - 디스크 드라이브는 메인 메모리보다 1000배 크지만, 데이터를 읽어들이는데 메인 메모리보다 천만 배 더 오래 걸릴 수 있다
- 마찬가지로 레지스터 파일은 수백 바이트의 정보를 저장하는 반면, 메인 메모리의 경우 십억 개의 바이트를 저장한다
  - 레지스터 속도 = 약 메인 메모리 속도 x 100
    - 속도 = 바이트 / 데이터를 읽어들이는데 걸리는 시간
- 반도체 기술이 발달함에 따라 프로세서-메모리 간 속도 격차가 증가하고 있다
- 시스템 설계자는 이 격차에 대응하기 위해 캐시 메모리(=캐시)를 고안

> 메인 메모리를 더 빠르게 동작하도록 만드는 것보다 프로세서를 더 빨리 동작하도록 만드는 것이 더 쉽고 비용이 적게듬

#### 캐시

- 프로세서가 단기간에 필요로 할 가능성이 높은 정보를 임시로 저장할 목적으로 사용
- L1, L2 캐시는 SRAM(Static Random Access Memory)라는 하드웨어 기술로 구현됨
- L3 -> 프로그램이 지엽적인 영역의 코드와 데이터를 액세스하는 경향인 지역성(locality)을 활용하여 시스템이 매우 크고 빠른 메모리 효과를 얻을 수 있다는 것에서 시작
- 자주 액세스할 가능성이 높은 데이터를 캐시가 보관하도록 설정하면, 빠른 캐시를 이용해서 대부분의 메모리 작업 수행 가능

> 캐시를 이해하는 응용 프로그래머는 캐시를 이용해 프로그램 성능을 10배 이상 개선 가능

---

- L1 캐시
  - 약 수천 바이트 데이터 저장
  - 레지스터 파일만큼 빠른 속도
- L2 캐시
  - 수백 킬로 바이트 ~ 수 메가 바이트 데이터 저장
  - 프로세서와 전용 버스를 통해 연결됨
- L1 캐시의 속도 = L2 캐시의 속도 x 5
- L2 캐시의 속도 = 메인 메모리의 속도 x 5 ~ 10

### 1.6 저장장치들은 계층 구조를 이룬다

> 모든 컴퓨터 시스템의 저장 장치들은 메모리 계층 구조로 되어 있다

1. Regs
    - CPU Registers hold words retrieved from cache memory
2. L1 cache (SRAM)
    - L1 cache holds cache lines retrieved from L2 cache memory
3. L2 cache (SRAM)
    - L2 cache holds cache lines retrieved from L3 cache memory
4. L3 cache (SRAM)
    - L3 cache holds cache lines retrieved from main memory
5. Main memory(DRAM)
    - Main memory holds disk blocks retrieved from local disks
6. Local secondary Storage
    - Local disks hold files retrieved from disks on remote network server
7. Remote secondary Storage

> 메모리 계층 구조의 주요 아이디어는 한 레벨의 저장장치가 다음 하위 레벨 저장장치의 캐시 역할을 한다는 것이다

### 1.7 운영체제는 하드웨어를 관리한다

> 프로그램은 키보드나 디스플레이, 디스크나 메인 메모리를 직접 액세스 하지 않는다

쉘 프로그램이 프로그램을 로드하고 실행했을 때와 프로그램이 메세지를 출력할 때, 운영체제(Operating System)가 제공하는 서비스를 활용해서 보여줬다.

#### 운영체제

- 하드웨어와 소프트웨어 사이에 위치한 _소프트웨어 계층_
- 응용 프로그램이 하드웨어를 제어하려면 언제나 운영체제를 통해서 해야 한다
- 목적
    1. 제멋대로 동작하는 응용 프로그램들이 하드웨어를 잘못 사용하는 것을 막기 위해
    2. 응용 프로그램들이 단순하고 균일한 매커니즘을 사용하여 복잡하고 매우 다른 저수준 하드웨어 장치들을 조작할 수 있도록 하기 위해

#### 하드웨어

중앙 처리 장치, 모니터, 키보드, 마우스, 메인 메모리, 보조 기억 장치, 그래픽 카드, 사운드 카드, 메인보드와 같은 컴퓨터의 물리적 부품을 의미

#### 운영체제에 의한 추상화

|                   |                                                       |
| ----------------- | ----------------------------------------------------- |
| Files             | abstraction of I/O devices                            |
| Virtual memory    | abstraction of I/O devices, Main memory               |
| Processes         | abstraction of I/O devices, Main memory, Processor    |

### 1.7.1 프로세스

> 운영체제가 만드는 착각

운영체제는 프로그램이 프로세서, 메인 메모리, 입출력 장치를 모두 독차지하고 있는 것처럼 보이게 한다.  
프로세서는 프로그램 내의 인스트럭션들을 다른 방해없이 순차적으로 실행하는 것처럼 보인다.  
프로그램의 코드와 데이터가 시스템 메모리의 유일한 객체인 것처럼 보인다.

---

프로세스는 실행 중인 프로그램에 대한 운영체제의 추상화다.  
다수의 프로세스들은 동일한 시스템에서 동시에 실행될 수 있으며, 각 프로세스는 하드웨어를 배타적으로 사용하는 것처럼 느낀다.  
동시에 실행될 수 있다는 것은 한 프로세스의 인스트럭션들이 다른 프로세스의 인스트럭션들과 섞인다는 것을 의미한다.

#### context switching

대부분의 시스템에서 프로세스를 실행할 CPU의 숫자보다 더 많은 프로세스들이 존재한다.  
운영체제는 프로세스가 실행하는 데 필요한 모든 상태정보(context)의 변화를 추적한다.  
context라고 부르는 상태정보는 PC, 레지스터 파일, 메인 메모리의 현재 값을 포함하고 있다.  
어느 한순간에 단일 프로세서 시스템은 한 개의 프로세스의 코드만을 실행할 수 있다.  

현재 프로세스에서 다른 프로세스로 제어를 옮기려고 할 때, 운영체제는 현재 프로세스의 context를 저장하고 새 프로세스의 context를 복원시키는 문맥 전환을 실행하여 제어권을 새 프로세스에게 넘겨준다.  
새 프로세스는 이전에 중단했던 그 위치부터 다시 실행된다.

#### kernel

하나의 프로세스에서 다른 프로세스로의 전환은 운영체제 kernel에 의해 관리된다.  
kernel은 운영체제 코드의 일부분으로 메모리에 상주한다.

### 링크

- [union, find algorithm](https://gmlwjd9405.github.io/2018/08/31/algorithm-union-find.html)
