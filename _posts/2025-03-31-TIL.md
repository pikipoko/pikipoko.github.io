---
title: "1일1코테 1day"
date: 2025-03-31
categories: TIL
---

회사에서 사용하는 기본 언어는 c와 java이지만, 아직은 c만 능숙하게 작성할 수 있고, java는 사내 코드를 읽을 수 있고 응용은 가능한 수준이지만 아직 객체지향 개념을 제대로 이해하고 사용한다는 느낌을 받지 못했다.  

이러한 고민을 팀장님과 얘기를 해보니 객체지향을 제대로 알려면 c++로 먼저 공부해보는 걸 추천한다고 말씀하셔서, 회사에서는 java 공부와 개발을 병행하고 개인적으로 따로 c++를 공부해보라고 하셨다.  

혼자 공부하기에 좋은 방법은 개인적으로는 무작정 문제를 풀어보는 것이라 생각이 들어 시간과 심적 여유가 될 때 프로그래머스로 코딩테스트를 풀다가, 마침 항해99에서 1일1코테 프로젝트를 진행한다고 하여, 어떻게든 하루에 한 문제는 풀어보자는 생각으로 그냥 무작정 신청하였다.  

좋은 코딩테스트 문제를 고르는 것에도 시간이 들기 때문에 이러한 프로그램을 통해 시간을 절약할 수 있어 좋겠다는 생각이 있었고, 출석체크를 통해 의무감을 가지게 될 것이라 여러모로 좋을 것 같았다.  

레벨은 비기너/미들러/챌린저로 나뉘는데 일단 신청한 언어인 c++ 자체가 아직 print문도 작성할 줄 모르는 수준이라, 시간이 되면 미들러나 챌린저 문제도 풀어보고 할 생각으로 비기너로 신청하였다.  

---

비기너 문제를 풀어보니, 기본적으로 include할 라이브러리, using std::cout, cin, string, endl 이런 신기한 것들을 사용하면 된다는 걸 알게되었다.  
혼자 시작했으면 의무감이 없어서 시작하기 어려웠을 텐데 첫 날 문제는 그래도 풀어야지 하면서 풀면서 기본적인 hello문과 반복문을 쓸 줄 알게 되어 좋았다.  
기본적으로 c언어도 지원하기 때문에 반복문 같은 경우에는 동일한 형태로 코드를 작성해도 되서 편했고 좋았다.  

---

for문은 c언어와 동일하게 사용 가능했고, c언어에서는 printf, scanf로 입출력하던 것을 cout, cin으로 하면 된다는 것을 알게되었다. 자료형을 따로 %d나 %s처럼 지정 안해줘도 되서 편했다.

---

비기너 문제를 15분 정도해서 풀고 미들러 문제를 푸는데, 그동안 알고리즘 공부를 소홀히 했다는 것을 깨달았다..  
지난 1, 2월에 차근차근 프로그래머스에서 레벨 1로 문제를 풀어왔는데, 미들러 문제를 풀지 못했다.  
나름 학교 다닐 때 자료구조, 알고리즘은 A+를 받았는데 그동안 너무 손을 뗐었나보다.  
그래도 보너스 문제는 10분만에 풀어서 기분이 좋다.  

---

비기너 클럽장님이 문제를 풀다가 일정시간 넘게 걸리면, 고민하는 것도 좋지만 어차피 코딩테스트 문제는 풀 게 많으니 gpt에게 물어보면서 뭐가 문제일지 어떻게 접근하면 좋을지 처음에는 그렇게 해보는 것도 좋다고 하였다.  

지금은 코딩테스트 감이 많이 떨어진 상태라 미들러 문제를 풀다가 감이 안 와서 문제와 내 코드를 gpt에게 보여주니 **에라토스테네스의 체** 알고리즘이라는 것을 이용하여 푸는 방식이 정석이라고 설명을 해주었다.  

## 에라토스테네스의 체

> **어떤 수의 배수는 절대 소수가 될 수 없다**라는 사실을 이용해서 소수가 아닌 수들을 지워나가는 방식

gpt를 통해 해당 방식이 이 문제를 푸는 데 참 적합하다는 생각이 들었고, 와 라는 소리가 나왔다.  
하지만 생각해보니 어떤 수가 주어졌을 때 소수인지 아닌지 판별할 때에는 적합하지 않을 것 같아서 또다시 gpt한테 물어보니, 생각한대로 어떤 한 숫자가 소수인지 아닌지 판별할 때는 적합하지 않다고 한다.  

그럴때는 루트로 나눠보는 방식(sqrt(n)? 방식이라는 데 모르겠다.)

code로 나타내면 아래와 같다.

```c++
bool isPrime(int n) {
    if (n < 2) return false;
    for (int i = 2; i * i <= n; i++) {
        if (n % i == 0) return false;
    }
    return true;
}
```

`i`를 계속 증가시키면서, 나누어 떨어지는 지 보고, i를 증가시키면서 나누어떨어지는 지 봤기 때문에 `i` 보다 아래 숫자로는 안 나누어 떨어지니까 `i * i` 보다 작거나 같은 지만 판단한다. 그러면 `2 -> 4`, `3 -> 9`, `4 -> 16`, `5 -> 25`, `6 -> 36`, `7 -> 49`, `8 -> 64` 이런 식으로 `i`가 1씩 증가할 때 마다 `y = x^2` 함수 처럼 점진적으로 값을 비교해 나갈 수 있다. 그래서 시간 복잡도가 `O(√n)` 가 나온다고 한다.  

기가 막힌 대답이다.